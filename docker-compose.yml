services:
  build:
    build:
      context: .
      dockerfile: Dockerfile
      # Target the builder stage so the container has a real shell/filesystem.
      target: builder
    # Run as the host user so the output binary is owned by them, not root.
    # The UID/GID are read from the environment; set them in a .env file or
    # export them in your shell before running docker compose:
    #   export UID GID && docker compose run --rm build
    user: "${UID:-1000}:${GID:-1000}"
    # Redirect Go's build cache to /out/.cache so the non-root user can write
    # to it. The cache is preserved across runs via the host-mounted dist/ dir,
    # which also speeds up incremental rebuilds.
    environment:
      GOCACHE: /out/.cache/go-build
      GOMODCACHE: /out/.cache/go-mod
    # Override the default entrypoint so the container runs the build command
    # and exits immediately â€” it is not a long-running service.
    entrypoint: []
    command:
      - go
      - build
      - -trimpath
      - -ldflags=-s -w
      - -o
      - /out/installer
      - ./cmd/main.go
    volumes:
      # Mount the project root read-only so local edits are picked up without
      # rebuilding the image (dependencies are already cached in the image).
      - .:/src:ro
      # Mount a host directory to receive the compiled binary.
      # Run:  mkdir -p dist
      # Then: docker compose run --rm build
      # The binary will appear at dist/installer on the host.
      - ./dist:/out
