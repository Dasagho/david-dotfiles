# huh Forms Enhancement Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace the hand-rolled `bubbles/list` selector and custom `bubbles/textinput` binary picker with `charmbracelet/huh` forms for a polished, consistent terminal UI.

**Architecture:** Three surfaces are enhanced. (1) `tui/selector.go` becomes a thin wrapper around a `*huh.Form` with `MultiSelect`. (2) `tui/picker.go` replaces the custom cursor-based file browser with `huh.FilePicker` and the `textinput` naming phase with `huh.Input`. The multi-bin loop (pick file → name it → confirm "add another?") is driven by sequential embedded huh forms. (3) `tui/model.go` is updated minimally to route to the new picker sub-model shape. The root model's channel-driven architecture and all installer logic remain unchanged.

**Tech Stack:** Go 1.24, `github.com/charmbracelet/huh` (add to go.mod), `github.com/charmbracelet/bubbletea`, `github.com/charmbracelet/lipgloss`

---

### Task 1: Add huh dependency

**Files:**
- Modify: `go.mod`, `go.sum`

**Step 1: Add the dependency**

```bash
go get github.com/charmbracelet/huh@latest
```

**Step 2: Verify it resolves**

```bash
go build ./...
```

Expected: clean build (no new source files touch huh yet).

**Step 3: Commit**

```bash
git add go.mod go.sum
git commit -m "chore: add charmbracelet/huh dependency"
```

---

### Task 2: Replace selector with huh.MultiSelect

**Files:**
- Modify: `tui/selector.go` (full rewrite)
- Modify: `tui/model.go` (update type references and Init routing)

**Context:**

The current `selectorModel` wraps a `bubbles/list` with space-toggle multi-select. The new version embeds a `*huh.Form` containing one `huh.NewMultiSelect[catalog.Program]` field. The form's `State == huh.StateCompleted` replaces the `done bool` flag. `huh.StateAborted` replaces `quit bool`.

`huh.Form` is a `tea.Model`, so it fits the existing pattern: the root model calls `m.selector.Update(msg)` and reads `m.selector.done` / `m.selector.quit` exactly as before. The public surface of `selectorModel` does not change.

**Step 1: Rewrite `tui/selector.go`**

```go
package tui

import (
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/huh"
	"github.com/dsaleh/david-dotfiles/internal/catalog"
)

type selectorModel struct {
	form     *huh.Form
	selected []catalog.Program // populated when form completes
	done     bool
	quit     bool
}

func newSelectorModel(programs []catalog.Program) selectorModel {
	opts := make([]huh.Option[catalog.Program], len(programs))
	for i, p := range programs {
		opts[i] = huh.NewOption(p.Name+" — "+p.Repo, p)
	}

	var selected []catalog.Program

	form := huh.NewForm(
		huh.NewGroup(
			huh.NewMultiSelect[catalog.Program]().
				Title("Select programs to install").
				Description("space: toggle  •  enter: confirm  •  /: filter  •  q: quit").
				Options(opts...).
				Filterable(true).
				Value(&selected),
		),
	).WithHeight(20)

	return selectorModel{form: form}
}

func (m selectorModel) Init() tea.Cmd {
	return m.form.Init()
}

func (m selectorModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	// Let huh handle quit (ctrl+c / esc → StateAborted).
	form, cmd := m.form.Update(msg)
	if f, ok := form.(*huh.Form); ok {
		m.form = f
	}

	switch m.form.State {
	case huh.StateCompleted:
		// huh wrote into the &selected pointer inside the form; read it back.
		if sel, ok := m.form.Get("programs").([]catalog.Program); ok {
			m.selected = sel
		}
		m.done = true
	case huh.StateAborted:
		m.quit = true
		return m, tea.Quit
	}

	return m, cmd
}

func (m selectorModel) View() string {
	return m.form.View()
}

func (m selectorModel) selectedPrograms() []catalog.Program {
	return m.selected
}
```

> **Note on reading back the value:** `huh` writes selected values directly into the pointer you pass to `.Value(&selected)`. But because `selected` is a local variable in `newSelectorModel`, we need it accessible at `Update` time. Two approaches work:
>
> - Store a pointer to the slice on the model: add `result *[]catalog.Program` to the struct, pass `result` to `.Value()`, read `*m.result` in Update.
> - Use `.Key("programs")` on the field and `m.form.Get("programs")`.
>
> Use the pointer approach — it's simpler and doesn't require type-asserting `interface{}`. Revised struct:
>
> ```go
> type selectorModel struct {
>     form     *huh.Form
>     result   []catalog.Program // huh writes here via pointer
>     done     bool
>     quit     bool
> }
> ```
>
> In `newSelectorModel`:
> ```go
> m := selectorModel{}
> // ... build opts ...
> m.form = huh.NewForm(
>     huh.NewGroup(
>         huh.NewMultiSelect[catalog.Program]().
>             Title("Select programs to install").
>             Options(opts...).
>             Filterable(true).
>             Value(&m.result),
>     ),
> ).WithHeight(20)
> return m
> ```
>
> In `Update`, when `StateCompleted`, `m.result` already has the value — no `.Get()` needed.
>
> `selectedPrograms()` returns `m.result`.

**Step 2: Update `tui/model.go` — Init routing**

`RootModel.Init()` calls `m.selector.Init()`. This stays the same since `selectorModel.Init()` now delegates to `m.form.Init()`. No change needed here.

The `Update` in `RootModel` reads `m.selector.done` and `m.selector.quit` — these are still set by the new `selectorModel`. No change needed.

**Step 3: Build**

```bash
go build ./...
```

Expected: clean.

**Step 4: Smoke-test the selector manually**

```bash
go run ./cmd/main.go
```

Verify:
- List of programs appears with multi-select styling
- `space` toggles items
- `/` opens filter
- `enter` confirms and proceeds to install (or quits if none selected)
- `ctrl+c` / `esc` quits

**Step 5: Commit**

```bash
git add tui/selector.go tui/model.go
git commit -m "feat: replace bubbles/list selector with huh.MultiSelect"
```

---

### Task 3: Replace picker naming phase with huh.Input

**Files:**
- Modify: `tui/picker.go`

**Context:**

`picker.go` has two phases: `phaseBrowse` (custom cursor nav) and `phaseNaming` (raw `bubbles/textinput`). This task replaces only `phaseNaming` with an embedded `*huh.Form` containing a single `huh.NewInput`. The browse phase is untouched in this task (Task 4 replaces it).

The `pickerModel` struct currently holds `input textinput.Model`. Replace that with `namingForm *huh.Form` and `namingResult string`.

**Step 1: Update `pickerModel` struct**

Remove the `input textinput.Model` field. Add:

```go
namingForm   *huh.Form
namingResult string  // huh writes symlink name here
```

Remove `"github.com/charmbracelet/bubbles/textinput"` from imports. Add `"github.com/charmbracelet/huh"`.

**Step 2: Update `newPickerModel`**

Remove `ti := textinput.New()` and all `ti.*` setup. The naming form is built on-demand in `updateBrowse` when a file is selected (so it always has the correct pre-filled value). Initialise `namingForm` to `nil`.

**Step 3: Update `updateBrowse` — file selected branch**

Replace:

```go
m.input.SetValue(e.name)
m.input.CursorEnd()
m.input.Focus()
m.phase = phaseNaming
return m, textinput.Blink
```

With:

```go
m.selectedSrc = e.path
m.namingResult = e.name           // pre-fill with filename
m.namingForm = huh.NewForm(
    huh.NewGroup(
        huh.NewInput().
            Title("Symlink name for: " + filepath.Base(e.path)).
            Description("Name that will appear in ~/.local/bin/").
            Placeholder(e.name).
            Value(&m.namingResult).
            Validate(func(s string) error {
                if strings.TrimSpace(s) == "" {
                    return fmt.Errorf("name cannot be empty")
                }
                return nil
            }),
    ),
)
m.phase = phaseNaming
return m, m.namingForm.Init()
```

**Step 4: Rewrite `updateNaming`**

Replace the entire method:

```go
func (m pickerModel) updateNaming(msg tea.Msg) (tea.Model, tea.Cmd) {
    // ctrl+c → quit
    if k, ok := msg.(tea.KeyMsg); ok && k.String() == "ctrl+c" {
        m.quit = true
        return m, tea.Quit
    }

    form, cmd := m.namingForm.Update(msg)
    if f, ok := form.(*huh.Form); ok {
        m.namingForm = f
    }

    switch m.namingForm.State {
    case huh.StateCompleted:
        // m.namingResult was written by huh via the pointer
        name := strings.TrimSpace(m.namingResult)
        if name == "" {
            name = filepath.Base(m.selectedSrc)
        }
        m.added = append(m.added, catalog.Bin{
            Src: m.selectedSrc,
            Dst: name,
        })
        m.namingForm = nil
        m.phase = phaseBrowse
        return m, nil

    case huh.StateAborted:
        // esc/q → back to browse without adding
        m.namingForm = nil
        m.phase = phaseBrowse
        return m, nil
    }

    return m, cmd
}
```

**Step 5: Update `viewNaming`**

Replace the hand-rolled view with:

```go
func (m pickerModel) viewNaming() string {
    if m.namingForm == nil {
        return ""
    }
    return m.namingForm.View()
}
```

**Step 6: Update `Init`**

`pickerModel.Init()` currently returns `nil`. Keep it `nil` — the naming form's `Init()` is called inline when transitioning to `phaseNaming`.

**Step 7: Build and verify**

```bash
go build ./...
```

**Step 8: Smoke-test**

Run the tool, select a program, wait for extraction, navigate the file browser, press enter on a file — verify the huh Input prompt appears pre-filled with the filename, with styled border and validation.

**Step 9: Commit**

```bash
git add tui/picker.go
git commit -m "feat: replace textinput naming phase with huh.Input"
```

---

### Task 4: Replace custom file browser with huh.FilePicker

**Files:**
- Modify: `tui/picker.go` (replace `phaseBrowse` and all supporting browse code)
- Modify: `tui/model.go` (update `openNextPicker` to seed width/height into huh form)

**Context:**

The current `phaseBrowse` is ~200 lines of custom cursor/scroll code including `loadDir()`, `fileEntry`, `viewBrowse()`, and all browse key handling. This task replaces it entirely with `huh.NewFilePicker().CurrentDirectory(installDir).FileAllowed(true).DirAllowed(false)`.

The multi-bin loop ("add another?") is handled by adding a `phaseConfirm` with a `huh.NewConfirm` after each successful file+name pair. The flow becomes:

```
phaseBrowse (huh.FilePicker) → phaseNaming (huh.Input) → phaseConfirm (huh.Confirm) → phaseBrowse or done
```

**Step 1: Update `pickerPhase` constants**

```go
const (
    phaseBrowse  pickerPhase = iota
    phaseNaming
    phaseConfirm
)
```

**Step 2: Update `pickerModel` struct**

Remove: `entries []fileEntry`, `cursor int`, `currentDir string`.

Add: `browseForm *huh.Form`, `browseResult string`, `confirmForm *huh.Form`, `addAnother bool`.

Keep: `programName`, `installDir`, `namingForm`, `namingResult`, `selectedSrc`, `added`, `done`, `quit`, `width`, `height`.

Remove the `fileEntry` type entirely.

**Step 3: Update `newPickerModel`**

Remove all `loadDir()` call and related state. Build the initial `browseForm`:

```go
func newPickerModel(programName, installDir string) pickerModel {
    m := pickerModel{
        programName: programName,
        installDir:  installDir,
        phase:       phaseBrowse,
    }
    m.browseForm = m.buildBrowseForm()
    return m
}

func (m pickerModel) buildBrowseForm() *huh.Form {
    return huh.NewForm(
        huh.NewGroup(
            huh.NewFilePicker().
                Title(fmt.Sprintf("Select binary for %q", m.programName)).
                Description("Navigate to the binary inside the extracted archive").
                CurrentDirectory(m.installDir).
                ShowHidden(false).
                ShowSize(false).
                FileAllowed(true).
                DirAllowed(false).
                Value(&m.browseResult),  // ← note: this is a value copy issue — see below
        ),
    )
}
```

> **Important — pointer issue:** `buildBrowseForm` is called on a value receiver. The `.Value(&m.browseResult)` takes the address of the *copy's* field, not the original model's. To avoid this, build the form in `newPickerModel` directly using a pointer:
>
> ```go
> func newPickerModel(programName, installDir string) pickerModel {
>     m := pickerModel{
>         programName: programName,
>         installDir:  installDir,
>         phase:       phaseBrowse,
>     }
>     m.browseForm = huh.NewForm(
>         huh.NewGroup(
>             huh.NewFilePicker().
>                 Title(fmt.Sprintf("Select binary for %q", programName)).
>                 Description("Navigate to the binary inside the extracted archive.\nPress d to finish without adding more.").
>                 CurrentDirectory(installDir).
>                 ShowHidden(false).
>                 FileAllowed(true).
>                 DirAllowed(false).
>                 Value(&m.browseResult),
>         ),
>     )
>     return m
> }
> ```
>
> And similarly for `namingForm` — rebuild it in-place with `&m.namingResult` each time a file is selected, done from a pointer receiver or directly in the update method on the local copy before returning.

**Step 4: Rewrite `updateBrowse`**

```go
func (m pickerModel) updateBrowse(msg tea.Msg) (tea.Model, tea.Cmd) {
    // Allow quitting with ctrl+c or 'd' (done/skip) at any time.
    if k, ok := msg.(tea.KeyMsg); ok {
        switch k.String() {
        case "ctrl+c":
            m.quit = true
            return m, tea.Quit
        case "d", "D":
            m.done = true
            return m, nil
        }
    }

    form, cmd := m.browseForm.Update(msg)
    if f, ok := form.(*huh.Form); ok {
        m.browseForm = f
    }

    switch m.browseForm.State {
    case huh.StateCompleted:
        // m.browseResult was written by huh (full path of selected file)
        m.selectedSrc = m.browseResult
        // Build naming form with the selected file's basename as default.
        m.namingResult = filepath.Base(m.browseResult)
        m.namingForm = huh.NewForm(
            huh.NewGroup(
                huh.NewInput().
                    Title("Symlink name for: " + filepath.Base(m.browseResult)).
                    Description("Name that will appear in ~/.local/bin/").
                    Placeholder(m.namingResult).
                    Value(&m.namingResult).
                    Validate(func(s string) error {
                        if strings.TrimSpace(s) == "" {
                            return fmt.Errorf("name cannot be empty")
                        }
                        return nil
                    }),
            ),
        )
        m.phase = phaseNaming
        return m, m.namingForm.Init()

    case huh.StateAborted:
        // esc/q from file picker → done (no more bins to add)
        m.done = true
        return m, nil
    }

    return m, cmd
}
```

**Step 5: Rewrite `updateNaming`** (from Task 3, now extended to go to `phaseConfirm`)

After appending to `m.added`, instead of returning to `phaseBrowse` immediately, show a confirm:

```go
case huh.StateCompleted:
    name := strings.TrimSpace(m.namingResult)
    if name == "" {
        name = filepath.Base(m.selectedSrc)
    }
    m.added = append(m.added, catalog.Bin{Src: m.selectedSrc, Dst: name})
    m.namingForm = nil

    // Ask "add another binary?"
    m.addAnother = false
    m.confirmForm = huh.NewForm(
        huh.NewGroup(
            huh.NewConfirm().
                Title("Add another binary from this program?").
                Affirmative("Yes").
                Negative("No, done").
                Value(&m.addAnother),
        ),
    )
    m.phase = phaseConfirm
    return m, m.confirmForm.Init()
```

**Step 6: Add `updateConfirm`**

```go
func (m pickerModel) updateConfirm(msg tea.Msg) (tea.Model, tea.Cmd) {
    if k, ok := msg.(tea.KeyMsg); ok && k.String() == "ctrl+c" {
        m.quit = true
        return m, tea.Quit
    }

    form, cmd := m.confirmForm.Update(msg)
    if f, ok := form.(*huh.Form); ok {
        m.confirmForm = f
    }

    switch m.confirmForm.State {
    case huh.StateCompleted:
        m.confirmForm = nil
        if m.addAnother {
            // Reset browse form for another pick.
            m.browseResult = ""
            m.browseForm = huh.NewForm(
                huh.NewGroup(
                    huh.NewFilePicker().
                        Title(fmt.Sprintf("Select another binary for %q", m.programName)).
                        CurrentDirectory(m.installDir).
                        ShowHidden(false).
                        FileAllowed(true).
                        DirAllowed(false).
                        Value(&m.browseResult),
                ),
            )
            m.phase = phaseBrowse
            return m, m.browseForm.Init()
        }
        // User said "no" — done.
        m.done = true
        return m, nil

    case huh.StateAborted:
        // Treat abort as "no, done".
        m.confirmForm = nil
        m.done = true
        return m, nil
    }

    return m, cmd
}
```

**Step 7: Update `Update` dispatch**

```go
func (m pickerModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    if ws, ok := msg.(tea.WindowSizeMsg); ok {
        m.width, m.height = ws.Width, ws.Height
        return m, nil
    }
    switch m.phase {
    case phaseBrowse:
        return m.updateBrowse(msg)
    case phaseNaming:
        return m.updateNaming(msg)
    case phaseConfirm:
        return m.updateConfirm(msg)
    }
    return m, nil
}
```

**Step 8: Update `View` dispatch**

```go
func (m pickerModel) View() string {
    switch m.phase {
    case phaseBrowse:
        if m.browseForm != nil {
            return m.browseForm.View()
        }
    case phaseNaming:
        if m.namingForm != nil {
            return m.namingForm.View()
        }
    case phaseConfirm:
        if m.confirmForm != nil {
            return m.confirmForm.View()
        }
    }
    return ""
}
```

**Step 9: Delete dead code**

Remove from `picker.go`:
- `fileEntry` struct
- `loadDir()` method
- `viewBrowse()` method
- `viewNaming()` method (replaced by huh's view)
- All `pickerBorder`, `pickerCursor`, `pickerDirStyle`, `pickerFileStyle`, `pickerHintStyle`, `pickerInputStyle`, `pickerLabelStyle`, `pickerPathStyle` style vars (replaced by huh theme)
- `pickerHeader`, `pickerAddedStyle` — may keep `pickerAddedStyle` for the "added" list display, which you still render manually at the bottom of the confirm form's description or in the browse form's description

**Step 10: Update `tui/model.go` — seed huh form size**

`openNextPicker` currently seeds `picker.width` and `picker.height`. The huh forms also need window size. After building the picker, forward the size:

```go
func (m *RootModel) openNextPicker() tea.Cmd {
    req := m.progress.pickerQueue[0]
    m.progress.pickerQueue = m.progress.pickerQueue[1:]
    m.activePicker = &req

    picker := newPickerModel(req.Program, req.InstallDir)
    if m.windowWidth > 0 {
        picker.width = m.windowWidth
        picker.height = m.windowHeight
        if picker.browseForm != nil {
            picker.browseForm = picker.browseForm.WithWidth(m.windowWidth)
        }
    }
    m.picker = picker
    m.screen = screenBinPicker
    return m.picker.Init()
}
```

Also forward `WindowSizeMsg` to the active huh forms in the picker's `Update` — the existing `if ws, ok := msg.(tea.WindowSizeMsg)` block in `pickerModel.Update` already passes the size; huh forms propagate window size internally when they receive it via their own `Update`.

**Step 11: Build**

```bash
go build ./...
```

Fix any remaining compile errors (unused imports, removed fields).

**Step 12: Full smoke test**

```bash
go run ./cmd/main.go
```

Verify end-to-end:
1. MultiSelect selector appears → select one program → enter
2. Progress screen shows downloading/extracting
3. huh FilePicker appears rooted to `~/.local/share/{name}/`
4. Navigate to binary, press enter
5. huh Input appears pre-filled with filename → edit or accept → enter
6. huh Confirm "add another?" → choose No
7. Progress screen resumes → Done → shows summary
8. Verify symlink exists: `ls -la ~/.local/bin/{name}`

For multi-program: repeat with 2 programs, verify pickers appear sequentially.

**Step 13: Commit**

```bash
git add tui/picker.go tui/model.go
git commit -m "feat: replace custom file browser with huh.FilePicker + Confirm loop"
```

---

### Task 5: Polish — theme and form width

**Files:**
- Modify: `tui/selector.go`
- Modify: `tui/picker.go`
- Modify: `tui/model.go`

**Context:**

Apply a consistent theme and reasonable form widths across all huh forms.

**Step 1: Pick a theme**

Use `huh.ThemeCharm()` — matches charmbracelet's own tooling aesthetic. Apply globally:

In `newSelectorModel`:
```go
form := huh.NewForm(...).WithTheme(huh.ThemeCharm()).WithHeight(20)
```

In `newPickerModel` (browse form):
```go
m.browseForm = huh.NewForm(...).WithTheme(huh.ThemeCharm())
```

In `updateBrowse` (naming form rebuild):
```go
m.namingForm = huh.NewForm(...).WithTheme(huh.ThemeCharm())
```

In `updateNaming` (confirm form build):
```go
m.confirmForm = huh.NewForm(...).WithTheme(huh.ThemeCharm())
```

In `updateConfirm` (browse form rebuild):
```go
m.browseForm = huh.NewForm(...).WithTheme(huh.ThemeCharm())
```

**Step 2: Extract a package-level theme var**

To avoid repeating `.WithTheme(huh.ThemeCharm())` everywhere, define in `tui/model.go` (or a new `tui/theme.go`):

```go
var huhTheme = huh.ThemeCharm()
```

Then use `.WithTheme(huhTheme)` in all form constructors.

**Step 3: Build and verify**

```bash
go build ./...
go run ./cmd/main.go
```

Check visual consistency across all three form surfaces.

**Step 4: Commit**

```bash
git add tui/
git commit -m "style: apply consistent huh Charm theme across all forms"
```

---

## Notes on huh form pointer semantics

`huh` writes values into pointers you pass to `.Value()`. When the form is built inside a function with a local variable, the pointer becomes dangling after the function returns — huh still writes into it, but reading the field on the model struct won't see the update.

**Always pass `&m.fieldName`** where `m` is the model being constructed *in place* (not a copy), or store a separate result pointer on the struct. The safest pattern used throughout this plan is:

```go
// In newPickerModel or inside an Update method on the local copy `m`:
m.browseResult = ""
m.browseForm = huh.NewForm(
    huh.NewGroup(
        huh.NewFilePicker().Value(&m.browseResult),
    ),
)
// Return m — m.browseResult and the pointer inside browseForm both refer
// to the same location in the returned copy, which becomes the new model.
```

This works because Bubble Tea replaces the entire model on each Update call with the returned value.

---

## Testing strategy

There are no existing TUI tests (the `tui` package has no test files). Manual smoke testing is the primary verification. The existing tests in `internal/` packages are unaffected — run them to confirm no regressions:

```bash
go test ./internal/...
```
